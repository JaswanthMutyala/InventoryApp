{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 51, "column": 0}, "map": {"version":3,"sources":["file:///E:/inventory-app/lib/db.js"],"sourcesContent":["const path = require('path');\r\n\r\nlet db;\r\n\r\nif (typeof window === 'undefined') {\r\n  // Only load better-sqlite3 in Node.js environment (server-side)\r\n  const Database = require('better-sqlite3');\r\n  const dbPath = path.join(process.cwd(), 'inventory.db');\r\n  db = new Database(dbPath);\r\n}\r\n\r\n// Initialize database with tables\r\nconst initDb = () => {\r\n    // Users table\r\n    db.prepare(`\r\n    CREATE TABLE IF NOT EXISTS users (\r\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n      student_id TEXT UNIQUE NOT NULL,\r\n      name TEXT NOT NULL,\r\n      role TEXT DEFAULT 'member' CHECK(role IN ('admin', 'member')),\r\n      password TEXT,\r\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n    )\r\n  `).run();\r\n\r\n    // Add role column if it doesn't exist (migration for existing databases)\r\n    try {\r\n        db.prepare('ALTER TABLE users ADD COLUMN role TEXT DEFAULT \"member\" CHECK(role IN (\"admin\", \"member\"))').run();\r\n    } catch (err) {\r\n        // Column already exists, ignore error\r\n    }\r\n\r\n    // Add password column if it doesn't exist (migration for existing databases)\r\n    try {\r\n        db.prepare('ALTER TABLE users ADD COLUMN password TEXT').run();\r\n    } catch (err) {\r\n        // Column already exists, ignore error\r\n    }\r\n\r\n    // Products table\r\n    db.prepare(`\r\n    CREATE TABLE IF NOT EXISTS products (\r\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n      name TEXT NOT NULL,\r\n      description TEXT,\r\n      quantity INTEGER DEFAULT 0,\r\n      image_url TEXT,\r\n      created_at DATETIME DEFAULT CURRENT_TIMESTAMP\r\n    )\r\n  `).run();\r\n\r\n    // Transactions table (Logs)\r\n    db.prepare(`\r\n    CREATE TABLE IF NOT EXISTS transactions (\r\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n      product_id INTEGER NOT NULL,\r\n      user_id INTEGER NOT NULL,\r\n      type TEXT CHECK(type IN ('CHECKOUT', 'CHECKIN')) NOT NULL,\r\n      quantity INTEGER NOT NULL,\r\n      timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n      FOREIGN KEY (product_id) REFERENCES products (id),\r\n      FOREIGN KEY (user_id) REFERENCES users (id)\r\n    )\r\n  `).run();\r\n\r\n    // Access logs table\r\n    db.prepare(`\r\n    CREATE TABLE IF NOT EXISTS access_logs (\r\n      id INTEGER PRIMARY KEY AUTOINCREMENT,\r\n      user_id INTEGER NOT NULL,\r\n      student_id TEXT NOT NULL,\r\n      name TEXT NOT NULL,\r\n      role TEXT NOT NULL,\r\n      accessed_at DATETIME DEFAULT CURRENT_TIMESTAMP,\r\n      FOREIGN KEY (user_id) REFERENCES users (id)\r\n    )\r\n  `).run();\r\n};\r\n\r\n// Clear all data functions\r\nconst clearAllData = () => {\r\n    try {\r\n        db.prepare('DELETE FROM transactions').run();\r\n        db.prepare('DELETE FROM products').run();\r\n        console.log('âœ… All history and inventory cleared');\r\n    } catch (err) {\r\n        console.error('Error clearing data:', err);\r\n    }\r\n};\r\n\r\n// Get user statistics\r\nconst getUserStats = () => {\r\n    try {\r\n        const admins = db.prepare('SELECT COUNT(*) as count FROM users WHERE role = \"admin\"').get();\r\n        const members = db.prepare('SELECT COUNT(*) as count FROM users WHERE role = \"member\"').get();\r\n        return {\r\n            adminCount: admins?.count || 0,\r\n            memberCount: members?.count || 0\r\n        };\r\n    } catch (err) {\r\n        console.error('Error getting user stats:', err);\r\n        return { adminCount: 0, memberCount: 0 };\r\n    }\r\n};\r\n\r\n// Get all users\r\nconst getAllUsers = () => {\r\n    try {\r\n        return db.prepare('SELECT id, student_id, name, role, password, created_at FROM users ORDER BY role DESC, created_at ASC').all();\r\n    } catch (err) {\r\n        console.error('Error getting all users:', err);\r\n        return [];\r\n    }\r\n};\r\n\r\n// Delete user\r\nconst deleteUser = (userId) => {\r\n    try {\r\n        // Delete user's transactions first\r\n        db.prepare('DELETE FROM transactions WHERE user_id = ?').run(userId);\r\n        // Delete user\r\n        db.prepare('DELETE FROM users WHERE id = ?').run(userId);\r\n        return true;\r\n    } catch (err) {\r\n        console.error('Error deleting user:', err);\r\n        return false;\r\n    }\r\n};\r\n\r\n// Log user access\r\nconst logUserAccess = (userId, studentId, name, role) => {\r\n    try {\r\n        db.prepare('INSERT INTO access_logs (user_id, student_id, name, role) VALUES (?, ?, ?, ?)').run(userId, studentId, name, role);\r\n        return true;\r\n    } catch (err) {\r\n        console.error('Error logging access:', err);\r\n        return false;\r\n    }\r\n};\r\n\r\n// Get all access logs\r\nconst getAccessLogs = () => {\r\n    try {\r\n        return db.prepare('SELECT id, user_id, student_id, name, role, accessed_at FROM access_logs ORDER BY accessed_at DESC').all();\r\n    } catch (err) {\r\n        console.error('Error getting access logs:', err);\r\n        return [];\r\n    }\r\n};\r\n\r\ninitDb();\r\n\r\n// Default export for backward compatibility\r\nmodule.exports = db;\r\n// Named exports\r\nmodule.exports.clearAllData = clearAllData;\r\nmodule.exports.getUserStats = getUserStats;\r\nmodule.exports.getAllUsers = getAllUsers;\r\nmodule.exports.deleteUser = deleteUser;\r\nmodule.exports.logUserAccess = logUserAccess;\r\nmodule.exports.getAccessLogs = getAccessLogs;\r\nmodule.exports.db = db;\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 210, "column": 0}, "map": {"version":3,"sources":["file:///E:/inventory-app/app/api/transactions/outstanding/route.js"],"sourcesContent":["import db from '@/lib/db';\r\nimport { NextResponse } from 'next/server';\r\n\r\nexport async function GET(request) {\r\n    try {\r\n        const { searchParams } = new URL(request.url);\r\n        const user_id = searchParams.get('user_id');\r\n        const product_id = searchParams.get('product_id');\r\n\r\n        if (!user_id) {\r\n            return NextResponse.json({ error: 'user_id is required' }, { status: 400 });\r\n        }\r\n\r\n        let query = `\r\n            SELECT \r\n                t.product_id,\r\n                p.name as product_name,\r\n                SUM(CASE WHEN t.type = 'CHECKOUT' THEN t.quantity ELSE 0 END) as total_checked_out,\r\n                SUM(CASE WHEN t.type = 'CHECKIN' THEN t.quantity ELSE 0 END) as total_checked_in,\r\n                SUM(CASE WHEN t.type = 'CHECKOUT' THEN t.quantity ELSE 0 END) - \r\n                SUM(CASE WHEN t.type = 'CHECKIN' THEN t.quantity ELSE 0 END) as outstanding\r\n            FROM transactions t\r\n            JOIN products p ON t.product_id = p.id\r\n            WHERE t.user_id = ?\r\n        `;\r\n        \r\n        const params = [user_id];\r\n        \r\n        if (product_id) {\r\n            query += ` AND t.product_id = ?`;\r\n            params.push(product_id);\r\n        }\r\n\r\n        query += ` GROUP BY t.product_id, p.name HAVING outstanding > 0`;\r\n\r\n        const outstanding = db.prepare(query).all(...params);\r\n        return NextResponse.json(outstanding);\r\n    } catch (error) {\r\n        console.error('Error fetching outstanding quantities:', error);\r\n        return NextResponse.json({ error: 'Failed to fetch outstanding quantities' }, { status: 500 });\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAEO,eAAe,IAAI,OAAO;IAC7B,IAAI;QACA,MAAM,EAAE,YAAY,EAAE,GAAG,IAAI,IAAI,QAAQ,GAAG;QAC5C,MAAM,UAAU,aAAa,GAAG,CAAC;QACjC,MAAM,aAAa,aAAa,GAAG,CAAC;QAEpC,IAAI,CAAC,SAAS;YACV,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAsB,GAAG;gBAAE,QAAQ;YAAI;QAC7E;QAEA,IAAI,QAAQ,CAAC;;;;;;;;;;;QAWb,CAAC;QAED,MAAM,SAAS;YAAC;SAAQ;QAExB,IAAI,YAAY;YACZ,SAAS,CAAC,qBAAqB,CAAC;YAChC,OAAO,IAAI,CAAC;QAChB;QAEA,SAAS,CAAC,qDAAqD,CAAC;QAEhE,MAAM,cAAc,sHAAE,CAAC,OAAO,CAAC,OAAO,GAAG,IAAI;QAC7C,OAAO,gJAAY,CAAC,IAAI,CAAC;IAC7B,EAAE,OAAO,OAAO;QACZ,QAAQ,KAAK,CAAC,0CAA0C;QACxD,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAyC,GAAG;YAAE,QAAQ;QAAI;IAChG;AACJ"}}]
}